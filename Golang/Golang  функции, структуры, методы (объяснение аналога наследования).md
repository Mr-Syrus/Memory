Вид функции в Go:

func название(параметры) (результаты){
	тело
}

пример:
```GO
package main
import "fmt"
func add(a int, b int) int {
	return a+b
}
func main(){
	fmt.Println("Сумма равна", add(10,19))
}
 ```

==var== - ключевое слово для объявления переменной, которое используется в случаях: объявление переменной вне функции

### Вне функции
- var a int    - обычное объявление
- var (
	name string 
	age int = 0
	mani = 5
	)

### Внутри функции
- a := 5

```GO
a *string = nil //ссылка *
```

ссылка всегда быстрее копирования

==структура== - тип данных, типо кастомный.
Она хранится как непрерывная структура.

```GO
type Person struct {
	Name string
	Age int
}
```

==композиция== - когда внутри одной структуры обращаются к другой структуре (это заменяет наследование)

```GO
type LocationMixin struct{
	Country *country.CountryEnum gorm: "type:enum('a')"
}
```

==метод== - (функция структуры) - функция, превязанная к определенному типу (получателю). Они позволяют типам данных иметь свое поведение. В ООП языках они как известно, внутри классов. В GO классов нет, так что привязывается к структурам.

```GO
func(н.название_структуры) имя_метода (параметры) вывод {
	тело_функции
}
```


==сигнатура== - просто описание чего либо, банально функция (это то что она принимает и возвращает). У структуры тоже есть сигнатура (это то что у нее хранится). У интерфейса тоже есть сигнатура хотя он не существует в коде, но его методы это тоже сигнатура, это обстрактный чертеж чего либо.

==конструктор== - в классическом понимании, как в С++ и Java их нет, но существует способ создания объектов с помощью функций. Такие функции возвращают экземпляр структуры и часто имеют префикс New + имя_типа.

Простой конструктор:
```GO
type Person struct {
	Name string
	Age int
}
// конструктор для Person
func NewPerson(name string, age int) *Person{
	return &Person{
		Name: name,
		Age: ago,
	}
}
func main(){
	p:=NewPerson("Alice",20)
	fmt.Println(p.Name, p.Age)
}
```

==errors== - тип встроенный, интерфейс для обработки ошибок.

==log== - пакет для простого логирования

==log.Fatal== - немедленное завершение работы и вывод сообщение об ошибке

```GO
type User struct {
	Name string
	Email string
}
//конструктор
func NewValidUser(name string, email int)(*User, error){
	if name == ""{
		return nil, errors.New("Поле имя не может быть пустым")
	}
	if !isValidEmail(email){
		return nil, errors.New("Поле почта не может быть пустым")
	}
	return & User{
		Name: name,
		Email: email,
	}, nil
}
func main(){
	u.err := ("Alice", "email@mail.com")
	if err != nil {
		log.Fatal(err)
	}
}
fmt.Println("%s, вы умеете вводить буквы в поля и мы сохранили ваше мыло", u.Name)
```

