## Пакеты

==Пакет в Go== - способ организации и группировки связанного кода. Каждый файл в Go насинается с объявления пакета.

Пакеты используются для:
- Организации кода
- Сокрытия реализации (инкапсуляция) //подробнее в статье [[Паттерны проектирования]]
- Повторного использования кода

==package main== - специальный пакет, с которого начинается выполнение программы. Он должен содержать функцию main().
==Импорт пакетов== - реализуется через ключевое слово import. Если импортированный пакет не будет использован, то код не скомпилируется.

### Тупое объяснение
Пакеты как комнаты в панельке. У каждого есть свой функционал.

### Пример использования
```Go
package main // Главный пакет, с которого начинается программа
import (    // Импорт сторонних пакетов
	"fmt"
	"math"
)

func main() {
	fmt.Println("Привет, мир!")
	fmt.Println("Квадратный корень из 16:", math.Sqrt(16))
}
```

## Переменные

==Переменная== - именованное место в памяти для хранения значения.

### Способы объявления

1. **var имя тип = значение** - полное объявление
2. **var имя = значение** - тип выводится компилятором
3. **имя := значение** - краткое объявление (только внутри функций)
4. **var имя тип** - объявление без инициализации (значение по умолчанию)

### Типы данных

1. Базовые: int, float64, string и тд.
2. Составные типы: массивы, срезы, структуры и тд.

##### Базовые

##### Составные типы

#### Тупое объяснение

==Переменные== - коробки с этикетками. Мы создаем коробку, подписываем его и кладем внутрь значение.

#### Пример использования

```Go
package main

import "fmt"

func main() {
    // Полное объявление
    var age int = 25

    // С выводом типа
    var name = "Анна"

    // Краткое объявление (только в функциях)
    salary := 1000.50

    // Несколько переменных
    var (
        city    = "Москва"
        country = "Россия"
    )

    // Константа
    const pi = 3.14

    fmt.Println("Имя:", name, "Возраст:", age)
    fmt.Println("Зарплата:", salary)
    fmt.Println("Город:", city, "Страна:", country)
    fmt.Println("Число Пи:", pi)
}
```

## Функция

==Функция== - независимый блок кода, который выполняет определенную задачу. Функция может принимать параметры и возвращать результаты.

Особенности:
- Функции могут возвращать несколько значений
- Именованные возвращаемые значения - можно объявить переменные для возврата в сигнатуре функции.
- Функции являются первокласными типами - их можно передать как аргументы, возвращать из функций и присваивать переменным.

### Тупое объяснение

==Функция== - рецепт. Вы даете ингридиенты (входные параметры), выполняете шаги (тело функции) и получаете результат (возвращаемое значение).

### Пример

```Go
package main

import "fmt"

// Функция без параметров и возвращаемого значения
func sayHello() {
    fmt.Println("Привет!")
}

// Функция с одним параметром
func greetPerson(name string) {
    fmt.Println("Привет,", name)
}

// Функция с параметрами и возвращаемым значением
func addNumbers(a int, b int) int {
    return a + b
}

// Функция с несколькими возвращаемыми значениями
func calculate(a, b int) (int, int) {
    sum := a + b
    product := a * b
    return sum, product
}

// Именованные возвращаемые значения
func divide(a, b float64) (result float64, err bool) {
    if b == 0 {
        return 0, true  // ошибка: деление на ноль
    }
    result = a / b
    return result, false // ошибки нет
}

func main() {
    sayHello()
    greetPerson("Мария")
    
    result := addNumbers(5, 3)
    fmt.Println("5 + 3 =", result)
    
    sum, product := calculate(4, 5)
    fmt.Printf("Сумма: %d, Произведение: %d\n", sum, product)
    
    res, err := divide(10, 2)
    if err {
        fmt.Println("Ошибка деления!")
    } else {
        fmt.Println("10 / 2 =", res)
    }
}
```

## Структуры

==Структура== - составной тип данных, который группирует поля (переменные) под одним именем. Поля структуры могут быть разных типов.

Особенности:
- структуры определяют новые типы данных.
- поля структуры могут быть экспортируемыми/публичными (с заглавной буквы) или не экспартируемыми/приватными (со строчной).
- К структурам можно привязать методы (функции работающие с конкретной структурой) подробнее в [[Golang  функции, структуры, методы (объяснение аналога наследования)]].

Терминалогия
- поля (fields): переменные пренадлежащие структуре
- методы (methods): функции, привязанные к конкретному типу
- получатель (receiver): параметр, связывающий метод с структурой
- **Value** vs **Pointer** receivers: методы могут работать с копией или ссылаться на оригинал структуры.

 - * - это ссылка, физически это номер ячейки в памяти в которой хранится оригинал 

Синтаксис:
```Go
type ИмяСтруктуры struct {
    поле1 тип1
    поле2 тип2
    ...
}
```

### Тупое объяснение

==Структура== - это шаблон, анкета, форма. Вы создаете шаблон (структуру), а затем заполняете его конкретными данными (экземпляр структуры).

### Пример
```Go
package main

import "fmt"

// Объявление структуры
type Person struct {
    // Поля структуры
    Name    string
    Age     int
    Email   string
    isAdmin bool  // неэкспортируемое поле
}

// Метод с value receiver (работает с копией)
func (p Person) Introduce() string {
    return fmt.Sprintf("Меня зовут %s, мне %d лет", p.Name, p.Age)
}

// Метод с pointer receiver (работает с оригиналом)
func (p *Person) Birthday() {
    p.Age++  // Изменяем оригинальную структуру
}

// Метод для проверки доступа
func (p Person) CanEdit() bool {
    return p.isAdmin
}

// Конструктор (идиоматичный способ создания структур)
func NewPerson(name, email string, age int, isAdmin bool) Person {
    return Person{
        Name:    name,
        Age:     age,
        Email:   email,
        isAdmin: isAdmin,
    }
}

// Встраивание структур (composition)
type Address struct {
    City    string
    Street  string
    House   int
}

type Employee struct {
    Person   // Встроенная структура (наследование в стиле Go)
    Address  // Встроенная структура
    Position string
    Salary   float64
}

func main() {
    // Создание экземпляра структуры
    var person1 Person
    person1.Name = "Иван"
    person1.Age = 30
    person1.Email = "ivan@mail.com"
    person1.isAdmin = false
    
    // Литерал структуры
    person2 := Person{
        Name:    "Мария",
        Age:     25,
        Email:   "maria@mail.com",
        isAdmin: true,
    }
    
    // Использование конструктора
    person3 := NewPerson("Петр", "petr@mail.com", 35, false)
    
    fmt.Println(person1.Introduce())
    fmt.Println(person2.Introduce())
    
    person1.Birthday()
    fmt.Println("После дня рождения:", person1.Introduce())
    
    fmt.Println("Мария может редактировать?", person2.CanEdit())
    fmt.Println("Иван может редактировать?", person1.CanEdit())
    
    // Работа с встроенными структурами
    employee := Employee{
        Person: Person{
            Name: "Алексей",
            Age:  28,
        },
        Address: Address{
            City:   "Москва",
            Street: "Ленина",
            House:  15,
        },
        Position: "Разработчик",
        Salary:   150000,
    }
    
    // Прямой доступ к полям встроенных структур
    fmt.Printf("%s работает в %s на позиции %s\n", 
        employee.Name, // Из Person
        employee.City, // Из Address
        employee.Position)
}
```



