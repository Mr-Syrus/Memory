## Пакеты

==Пакет в Go== - способ организации и группировки связанного кода. Каждый файл в Go насинается с объявления пакета.

Пакеты используются для:
- Организации кода
- Сокрытия реализации (инкапсуляция) //подробнее в статье [[Паттерны проектирования]]
- Повторного использования кода

==package main== - специальный пакет, с которого начинается выполнение программы. Он должен содержать функцию main().
==Импорт пакетов== - реализуется через ключевое слово import. Если импортированный пакет не будет использован, то код не скомпилируется.

### Тупое объяснение
Пакеты как комнаты в панельке. У каждого есть свой функционал.

### Пример использования
```Go
package main // Главный пакет, с которого начинается программа
import (    // Импорт сторонних пакетов
	"fmt"
	"math"
)

func main() {
	fmt.Println("Привет, мир!")
	fmt.Println("Квадратный корень из 16:", math.Sqrt(16))
}
```

## Переменные

==Переменная== - именованное место в памяти для хранения значения.

### Способы объявления

1. **var имя тип = значение** - полное объявление
2. **var имя = значение** - тип выводится компилятором
3. **имя := значение** - краткое объявление (только внутри функций)
4. **var имя тип** - объявление без инициализации (значение по умолчанию)

### Типы данных

1. Базовые: int, float64, string и тд.
2. Составные типы: массивы, срезы, структуры и тд.

##### Базовые

##### Составные типы

#### Тупое объяснение

==Переменные== - коробки с этикетками. Мы создаем коробку, подписываем его и кладем внутрь значение.

#### Пример использования

```Go
package main

import "fmt"

func main() {
    // Полное объявление
    var age int = 25

    // С выводом типа
    var name = "Анна"

    // Краткое объявление (только в функциях)
    salary := 1000.50

    // Несколько переменных
    var (
        city    = "Москва"
        country = "Россия"
    )

    // Константа
    const pi = 3.14

    fmt.Println("Имя:", name, "Возраст:", age)
    fmt.Println("Зарплата:", salary)
    fmt.Println("Город:", city, "Страна:", country)
    fmt.Println("Число Пи:", pi)
}
```

## Функция

==Функция== - независимый блок кода, который выполняет определенную задачу. Функция может принимать параметры и возвращать результаты.

Особенности:
- Функции могут возвращать несколько значений
- Именованные возвращаемые значения - можно объявить переменные для возврата в сигнатуре функции.
- Функции являются первокласными типами - их можно передать как аргументы, возвращать из функций и присваивать переменным.

### Тупое объяснение

==Функция== - рецепт. Вы даете ингридиенты (входные параметры), выполняете шаги (тело функции) и получаете результат (возвращаемое значение).

### Пример

```Go
package main

import "fmt"

// Функция без параметров и возвращаемого значения
func sayHello() {
    fmt.Println("Привет!")
}

// Функция с одним параметром
func greetPerson(name string) {
    fmt.Println("Привет,", name)
}

// Функция с параметрами и возвращаемым значением
func addNumbers(a int, b int) int {
    return a + b
}

// Функция с несколькими возвращаемыми значениями
func calculate(a, b int) (int, int) {
    sum := a + b
    product := a * b
    return sum, product
}

// Именованные возвращаемые значения
func divide(a, b float64) (result float64, err bool) {
    if b == 0 {
        return 0, true  // ошибка: деление на ноль
    }
    result = a / b
    return result, false // ошибки нет
}

func main() {
    sayHello()
    greetPerson("Мария")
    
    result := addNumbers(5, 3)
    fmt.Println("5 + 3 =", result)
    
    sum, product := calculate(4, 5)
    fmt.Printf("Сумма: %d, Произведение: %d\n", sum, product)
    
    res, err := divide(10, 2)
    if err {
        fmt.Println("Ошибка деления!")
    } else {
        fmt.Println("10 / 2 =", res)
    }
}
```

## Структуры

==Структура== - составной тип данных, который группирует поля (переменные) под одним именем. Поля структуры могут быть разных типов.

Особенности:
- структуры определяют новые типы данных.
- поля структуры могут быть экспортируемыми/публичными (с заглавной буквы) или не экспартируемыми/приватными (со строчной).
- К структурам можно привязать методы (функции работающие с конкретной структурой) подробнее в [[Golang  функции, структуры, методы (объяснение аналога наследования)]].

Синтаксис:
```Go
type ИмяСтруктуры struct {
    поле1 тип1
    поле2 тип2
    ...
}
```

### Тупое объяснение

==Структура== - это шаблон, анкета, форма. Вы создаете шаблон (структуру), а затем заполняете его конкретными данными (экземпляр структуры).

### Пример
```Go
package main

import "fmt"

// Определение структуры
type Person struct {
    Name    string
    Age     int
    Email   string
    IsAdmin bool
}

// Метод для структуры Person
func (p Person) Introduce() {
    fmt.Printf("Меня зовут %s, мне %d лет. Мой email: %s\n", 
        p.Name, p.Age, p.Email)
}

// Функция, принимающая структуру
func createPerson(name string, age int, email string, isAdmin bool) Person {
    return Person{
        Name:    name,
        Age:     age,
        Email:   email,
        IsAdmin: isAdmin,
    }
}

func main() {
    // Создание экземпляра структуры
    var user1 Person
    user1.Name = "Иван"
    user1.Age = 30
    user1.Email = "ivan@mail.com"
    user1.IsAdmin = false

    // Краткая инициализация
    user2 := Person{
        Name:    "Мария",
        Age:     25,
        Email:   "maria@mail.com",
        IsAdmin: true,
    }

    // Создание через функцию
    user3 := createPerson("Петр", 35, "petr@mail.com", false)

    fmt.Println("Пользователь 1:", user1.Name, user1.Age)
    fmt.Println("Пользователь 2:", user2.Name, user2.Age)
    fmt.Println("Пользователь 3:", user3.Name, user3.Age)

    // Вызов метода
    user1.Introduce()
    user2.Introduce()
    user3.Introduce()
}
```



